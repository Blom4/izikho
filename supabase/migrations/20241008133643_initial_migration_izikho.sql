create schema if not exists "chats";

create table "chats"."messages" (
    "id" bigint generated by default as identity not null,
    "createdAt" bigint,
    "metadata" jsonb,
    "duration" bigint,
    "mimeType" text,
    "name" text,
    "remoteId" text,
    "repliedMessage" jsonb,
    "roomId" bigint not null,
    "showStatus" boolean,
    "size" bigint,
    "status" text,
    "type" text,
    "updatedAt" bigint,
    "uri" text,
    "waveForm" jsonb,
    "isLoading" boolean,
    "height" double precision,
    "width" double precision,
    "previewData" jsonb,
    "authorId" uuid not null,
    "text" text
);


alter table "chats"."messages" enable row level security;

create table "chats"."rooms" (
    "id" bigint generated by default as identity not null,
    "imageUrl" text,
    "metadata" jsonb,
    "name" text,
    "type" text,
    "userIds" uuid[] not null,
    "lastMessages" jsonb,
    "userRoles" jsonb,
    "createdAt" bigint not null,
    "updatedAt" bigint not null
);


alter table "chats"."rooms" enable row level security;

create table "chats"."users" (
    "firstName" text,
    "imageUrl" text,
    "lastName" text,
    "metadata" jsonb,
    "role" text,
    "id" uuid not null,
    "createdAt" bigint not null,
    "updatedAt" bigint not null,
    "lastSeen" bigint not null
);


alter table "chats"."users" enable row level security;

CREATE UNIQUE INDEX messages_pkey ON chats.messages USING btree (id);

CREATE UNIQUE INDEX rooms_pkey ON chats.rooms USING btree (id);

CREATE UNIQUE INDEX users_pkey ON chats.users USING btree (id);

alter table "chats"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "chats"."rooms" add constraint "rooms_pkey" PRIMARY KEY using index "rooms_pkey";

alter table "chats"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "chats"."messages" add constraint "messages_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "chats"."messages" validate constraint "messages_authorId_fkey";

alter table "chats"."messages" add constraint "messages_roomId_fkey" FOREIGN KEY ("roomId") REFERENCES chats.rooms(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "chats"."messages" validate constraint "messages_roomId_fkey";

alter table "chats"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "chats"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION chats.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    ts_in_milliseconds bigint;
BEGIN
  SELECT EXTRACT(epoch FROM NOW()) * 1000 INTO ts_in_milliseconds;
  insert into chats.users (id, "createdAt", "updatedAt", "lastSeen")
  values (new.id, ts_in_milliseconds, ts_in_milliseconds, ts_in_milliseconds);
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION chats.is_auth()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  return auth.uid() IS NOT NULL;
end;
$function$
;

CREATE OR REPLACE FUNCTION chats.is_chat_member(room_id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  members uuid[];
BEGIN
    SELECT "userIds" INTO members
      FROM chats.rooms
      WHERE id = room_id;
  return chats.is_member(members);
end;
$function$
;

CREATE OR REPLACE FUNCTION chats.is_member(members uuid[])
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  return auth.uid() = ANY(members);
end;
$function$
;

CREATE OR REPLACE FUNCTION chats.is_owner(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  return auth.uid() = user_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION chats.update_last_messages()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    ts_in_milliseconds bigint;
BEGIN
    SELECT EXTRACT(epoch FROM NOW()) * 1000 INTO ts_in_milliseconds;
    UPDATE chats.rooms
    SET "updatedAt" = ts_in_milliseconds,
        "lastMessages" = jsonb_build_array(NEW)
        WHERE id = NEW."roomId";
    RETURN NEW;
END;
$function$
;

grant delete on table "chats"."messages" to "anon";

grant insert on table "chats"."messages" to "anon";

grant references on table "chats"."messages" to "anon";

grant select on table "chats"."messages" to "anon";

grant trigger on table "chats"."messages" to "anon";

grant truncate on table "chats"."messages" to "anon";

grant update on table "chats"."messages" to "anon";

grant delete on table "chats"."messages" to "authenticated";

grant insert on table "chats"."messages" to "authenticated";

grant references on table "chats"."messages" to "authenticated";

grant select on table "chats"."messages" to "authenticated";

grant trigger on table "chats"."messages" to "authenticated";

grant truncate on table "chats"."messages" to "authenticated";

grant update on table "chats"."messages" to "authenticated";

grant delete on table "chats"."messages" to "service_role";

grant insert on table "chats"."messages" to "service_role";

grant references on table "chats"."messages" to "service_role";

grant select on table "chats"."messages" to "service_role";

grant trigger on table "chats"."messages" to "service_role";

grant truncate on table "chats"."messages" to "service_role";

grant update on table "chats"."messages" to "service_role";

grant delete on table "chats"."rooms" to "anon";

grant insert on table "chats"."rooms" to "anon";

grant references on table "chats"."rooms" to "anon";

grant select on table "chats"."rooms" to "anon";

grant trigger on table "chats"."rooms" to "anon";

grant truncate on table "chats"."rooms" to "anon";

grant update on table "chats"."rooms" to "anon";

grant delete on table "chats"."rooms" to "authenticated";

grant insert on table "chats"."rooms" to "authenticated";

grant references on table "chats"."rooms" to "authenticated";

grant select on table "chats"."rooms" to "authenticated";

grant trigger on table "chats"."rooms" to "authenticated";

grant truncate on table "chats"."rooms" to "authenticated";

grant update on table "chats"."rooms" to "authenticated";

grant delete on table "chats"."rooms" to "service_role";

grant insert on table "chats"."rooms" to "service_role";

grant references on table "chats"."rooms" to "service_role";

grant select on table "chats"."rooms" to "service_role";

grant trigger on table "chats"."rooms" to "service_role";

grant truncate on table "chats"."rooms" to "service_role";

grant update on table "chats"."rooms" to "service_role";

grant delete on table "chats"."users" to "anon";

grant insert on table "chats"."users" to "anon";

grant references on table "chats"."users" to "anon";

grant select on table "chats"."users" to "anon";

grant trigger on table "chats"."users" to "anon";

grant truncate on table "chats"."users" to "anon";

grant update on table "chats"."users" to "anon";

grant delete on table "chats"."users" to "authenticated";

grant insert on table "chats"."users" to "authenticated";

grant references on table "chats"."users" to "authenticated";

grant select on table "chats"."users" to "authenticated";

grant trigger on table "chats"."users" to "authenticated";

grant truncate on table "chats"."users" to "authenticated";

grant update on table "chats"."users" to "authenticated";

grant delete on table "chats"."users" to "service_role";

grant insert on table "chats"."users" to "service_role";

grant references on table "chats"."users" to "service_role";

grant select on table "chats"."users" to "service_role";

grant trigger on table "chats"."users" to "service_role";

grant truncate on table "chats"."users" to "service_role";

grant update on table "chats"."users" to "service_role";

create policy "chats.messages_grant_create"
on "chats"."messages"
as permissive
for insert
to public
with check (chats.is_chat_member("roomId"));


create policy "chats.messages_grant_delete"
on "chats"."messages"
as permissive
for delete
to public
using (chats.is_chat_member("roomId"));


create policy "chats.messages_grant_read"
on "chats"."messages"
as permissive
for select
to public
using (chats.is_chat_member("roomId"));


create policy "chats.messages_grant_update"
on "chats"."messages"
as permissive
for update
to public
using (chats.is_chat_member("roomId"))
with check (chats.is_chat_member("roomId"));


create policy "chats.rooms_grant_create"
on "chats"."rooms"
as permissive
for insert
to public
with check (chats.is_auth());


create policy "chats.rooms_grant_delete"
on "chats"."rooms"
as permissive
for delete
to public
using (chats.is_member("userIds"));


create policy "chats.rooms_grant_read"
on "chats"."rooms"
as permissive
for select
to public
using (chats.is_member("userIds"));


create policy "chats.rooms_grant_update"
on "chats"."rooms"
as permissive
for update
to public
using (chats.is_member("userIds"))
with check (chats.is_member("userIds"));


create policy "chats.users_grant_create"
on "chats"."users"
as permissive
for insert
to public
with check (false);


create policy "chats.users_grant_delete"
on "chats"."users"
as permissive
for delete
to public
using (false);


create policy "chats.users_grant_read"
on "chats"."users"
as permissive
for select
to public
using (chats.is_auth());


create policy "chats.users_grant_update"
on "chats"."users"
as permissive
for update
to public
using (chats.is_auth())
with check (chats.is_owner(id));


create table "public"."games" (
    "id" uuid not null default gen_random_uuid(),
    "game_type" text,
    "created_at" timestamp with time zone not null default now(),
    "players" jsonb,
    "started" boolean,
    "game_over" boolean,
    "turn" jsonb,
    "extra_props" jsonb not null,
    "game_mode" text not null
);


alter table "public"."games" enable row level security;

create table "public"."notifications" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "game_id" uuid not null,
    "message" text,
    "sender_name" text not null,
    "viewed" boolean not null default false
);


alter table "public"."notifications" enable row level security;

CREATE UNIQUE INDEX game_pkey ON public.games USING btree (id);

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

alter table "public"."games" add constraint "game_pkey" PRIMARY KEY using index "game_pkey";

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."notifications" add constraint "public_notifications_game_id_fkey" FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "public_notifications_game_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_notification_for_new_game()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
  n_message text := 'invites you to join the '|| new.game_type ||' game';
begin
  insert into public.notifications (game_id,sender_name,message)
  values (new.id,new.players->0->>'username', n_message);
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.is_game_member(game_id uuid, sender_name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
v_players public.games.players%TYPE;
--v_uid text := '4169266b-a222-49ac-90c5-ac600fb0f786---'; 
v_uid text := auth.uid()::text; 

begin
  select players into v_players from public.games
  where games.id = game_id;
  
   return jsonb_path_exists(
     v_players, 
     '$[*] ? (@.id == $uid && @.username != $uname)',
     jsonb_build_object('uid',v_uid,'uname',sender_name)
   );
end;
$function$
;

create or replace view "public"."krusaid_games_view" as  SELECT games.id,
    games.game_type,
    games.created_at,
    games.players,
    games.started,
    games.game_over,
    games.turn
   FROM games
  WHERE (games.game_type = 'krusaid'::text);


CREATE OR REPLACE FUNCTION public.set_message_status_to_sent()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.status := 'sent';
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."games" to "anon";

grant insert on table "public"."games" to "anon";

grant references on table "public"."games" to "anon";

grant select on table "public"."games" to "anon";

grant trigger on table "public"."games" to "anon";

grant truncate on table "public"."games" to "anon";

grant update on table "public"."games" to "anon";

grant delete on table "public"."games" to "authenticated";

grant insert on table "public"."games" to "authenticated";

grant references on table "public"."games" to "authenticated";

grant select on table "public"."games" to "authenticated";

grant trigger on table "public"."games" to "authenticated";

grant truncate on table "public"."games" to "authenticated";

grant update on table "public"."games" to "authenticated";

grant delete on table "public"."games" to "service_role";

grant insert on table "public"."games" to "service_role";

grant references on table "public"."games" to "service_role";

grant select on table "public"."games" to "service_role";

grant trigger on table "public"."games" to "service_role";

grant truncate on table "public"."games" to "service_role";

grant update on table "public"."games" to "service_role";

grant delete on table "public"."notifications" to "anon";

grant insert on table "public"."notifications" to "anon";

grant references on table "public"."notifications" to "anon";

grant select on table "public"."notifications" to "anon";

grant trigger on table "public"."notifications" to "anon";

grant truncate on table "public"."notifications" to "anon";

grant update on table "public"."notifications" to "anon";

grant delete on table "public"."notifications" to "authenticated";

grant insert on table "public"."notifications" to "authenticated";

grant references on table "public"."notifications" to "authenticated";

grant select on table "public"."notifications" to "authenticated";

grant trigger on table "public"."notifications" to "authenticated";

grant truncate on table "public"."notifications" to "authenticated";

grant update on table "public"."notifications" to "authenticated";

grant delete on table "public"."notifications" to "service_role";

grant insert on table "public"."notifications" to "service_role";

grant references on table "public"."notifications" to "service_role";

grant select on table "public"."notifications" to "service_role";

grant trigger on table "public"."notifications" to "service_role";

grant truncate on table "public"."notifications" to "service_role";

grant update on table "public"."notifications" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."games"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all authenticatd users"
on "public"."games"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users"
on "public"."games"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."notifications"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable update for authenticated users"
on "public"."notifications"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "public.notifications_grant_read"
on "public"."notifications"
as permissive
for select
to public
using (is_game_member(game_id, sender_name));


CREATE TRIGGER on_game_created AFTER INSERT ON public.games FOR EACH ROW EXECUTE FUNCTION create_notification_for_new_game();

CREATE TRIGGER update_last_messages_trigger AFTER INSERT ON chats.messages FOR EACH ROW EXECUTE FUNCTION chats.update_last_messages();

CREATE TRIGGER update_status_before_insert BEFORE INSERT ON chats.messages FOR EACH ROW EXECUTE FUNCTION set_message_status_to_sent();

